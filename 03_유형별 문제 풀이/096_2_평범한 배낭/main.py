#https://www.acmicpc.net/problem/12865
# 백준 12865, 평범한 배낭


#테스트용 입력
import os
file = open(os.path.join(os.path.dirname(__file__), 'data.txt'), 'r')



# 쉬운 문제는 아니지만, 꼭 알아야하는 문제. 
""" 해결 아이디어
점화식을 잘 세우는게 포인트
모든 무게에 대해 최대 가치 저장하기 ! 

D[i][j] = 배낭에 넣은 물품의 무게 합이 j일때 얻을 수 있는 최대 가치

D[i-1][j] if j<W[i]....


2차원 배열을 이용함
N = 4, K = 7 일때
무게가 0일때는 다 0 
맨 첫번째 줄은 0으로 다 초기화
한 행씩 확인하는것, 

무게가 6이면
 - 무게가 6보다 작은 경우는 다 0이겠죠, 쪼개지지 않으니 알 수가 없으니
 - 이전에 구했던 값을 그대로 가지고 내려오고
 - 배낭에 해당 무게를 담을 수 있을 때부터는 (6보다 크거나 같을때)
   이전까지 구했던 결과중에서 무게가 0일 때 최대가치(0) + 현재물건의 가치(13) 을 더한 값과
   이전에 구했던 값을 비교해서 더 큰 값으로 수정
 - 무게가 7로 늘어났을 때는 이전까지 구했던 값중에 
   무게가 1일떄 최대가치(0) 과 13을 비교해서 더 큰 값이 대입
 - 다음번도 마찬가지

 무게가 4일때,, 
 - 이전에 구했던 값 넣고, 배낭에 넣을 수 있을 때 시점부터는 
 - 그 무게의 가치 8을 넣고
 - 5일때는 이전 값 4의 값에 1일때 값 더하고 ..
 - 6일때는 13이 들어가는데, 8과 13을 비교해서 13이 더 크기때문에 13이 들어간 것.

쭉 반복
"""





"""
제출용 입력
import sys
file = sys.stdin
"""




n, k= list(map(int, file.readline().replace('\n','').split()))

#테이블, k + 1만큼 할당해서 0 넣어준거고
dp = [[0] * (k + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    # 무게와 가치 값을 전달받아 매번 확인
    weight, value = list(map(int, file.readline().replace('\n','').split()))
    
    for j in range(1, k + 1):
        # 현재 무게보다 j가 더 작은경우는 위의 열에 있던 값을 그대로 넣는다.
        if j < weight:
            dp[i][j] = dp[i - 1][j]

        #그렇지 않다면 (더 크다면)
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight] + value)
            #위에 있던 값과        이전까지 구했던 최대가치에 현재 물건의 무게를 더한 값 중 큰 값을 넣겠다.


print(dp[n][k]) #맨 끝 값을 출력한다.

#이 문제는 꼭 숙달하세요. 

